#ifndef		__GAIA_NETWORK_ASYNC_SOCKET_H__
#define		__GAIA_NETWORK_ASYNC_SOCKET_H__

#include "gaia_type.h"
#include "gaia_assert.h"
#include "gaia_sync_atomic.h"
#include "gaia_sync_lock.h"
#include "gaia_sync_autolock.h"
#include "gaia_sync_lockpure.h"
#include "gaia_sync_autolockpure.h"
#include "gaia_ctn_bufferrw.h"
#include "gaia_network_ip.h"
#include "gaia_network_addr.h"
#include "gaia_network_base.h"
#include "gaia_network_socket.h"

namespace GAIA
{
	namespace NETWORK
	{
		/*!
			@brief Async context type.

		 		It is for internal usage.
		*/
		GAIA_ENUM_BEGIN(ASYNC_CONTEXT_TYPE)
			ASYNC_CONTEXT_TYPE_STOP,
			ASYNC_CONTEXT_TYPE_CONNECT,
			ASYNC_CONTEXT_TYPE_DISCONNECT,
			ASYNC_CONTEXT_TYPE_ACCEPT,
			ASYNC_CONTEXT_TYPE_SEND,
			ASYNC_CONTEXT_TYPE_RECV,
		GAIA_ENUM_END(ASYNC_CONTEXT_TYPE)

		/*!
			@brief Async context.
		 
		 		It is for internal usage.
		*/
		class AsyncContext : public GAIA::Base
		{
		public:
		#if GAIA_OS == GAIA_OS_WINDOWS
			OVERLAPPED _ovlp;
			WSABUF _buf;
			GAIA::NETWORK::AsyncSocket* pListenSocket;
			GAIA::NETWORK::AsyncSocket* pDataSocket;
			GAIA::U8 data[2000];
		#else
			GAIA::NETWORK::AsyncSocket* pSocket;
		#endif
			GAIA::NETWORK::ASYNC_CONTEXT_TYPE type;
		};

		/*!
			@brief Async socket type.
		*/
		GAIA_ENUM_BEGIN(ASYNC_SOCKET_TYPE)
			ASYNC_SOCKET_TYPE_CONNECTED, 	/*!< Specify the socket is a connected socket, it generated by call AsyncSocket::Connect function. */
			ASYNC_SOCKET_TYPE_ACCEPTING,	/*!< Specify the socket is a accepting socket, it generated by call AsyncDispatcher::OnCreateAcceptingSocket. */
			ASYNC_SOCKET_TYPE_ACCEPTED,		/*!< Specify the socket is a accepted socket, it generated by call AsyncDispatcher::OnCreateAcceptingSocket and be accepted(a connection be created when peer connect to current listen port). */
			ASYNC_SOCKET_TYPE_LISTEN,		/*!< Specify the socket is a listen socket, it generated by call AsyncDispatcher::AddListenSocket. */
		GAIA_ENUM_END(ASYNC_SOCKET_TYPE)

		/*!
			@brief TCP Async socket.
				This async socket class support stream socket only(TCP).
		*/
		class AsyncSocket : public GAIA::RefObject
		{
			friend class AsyncDispatcher;

		public:

			/*!
				@brief Constructor.

				@param disp [in] Specify the owner AsyncDispatcher.

				@param socktype [in] Specify the socket type. Default is GAIA::NETWORK::ASYNC_SOCKET_TYPE_CONNECTED. @see GAIA::NETWORK::ASYNC_SOCKET_TYPE.

				@see GAIA::NETWORK::ASYNC_SOCKET_TYPE.
			*/
			AsyncSocket(GAIA::NETWORK::AsyncDispatcher& disp, GAIA::NETWORK::ASYNC_SOCKET_TYPE socktype = GAIA::NETWORK::ASYNC_SOCKET_TYPE_CONNECTED);

			/*!
				@brief Destructor.

				@remarks If current async socket is created, it will be close automatically.
			*/
			virtual ~AsyncSocket();

			/*!
				@brief Get AsyncDispatcher.

				@return Return current AsyncSocket's AsyncDispatcher.
			*/
			GAIA::NETWORK::AsyncDispatcher& GetDispatcher() const{return *m_pDispatcher;}

			/*!
				@brief Get socket type.

				@return Return the socket type flag. @see GAIA::NETWORK::ASYNC_SOCKET_TYPE.

				@see GAIA::NETWORK::ASYNC_SOCKET_TYPE.
			*/
			GAIA::NETWORK::ASYNC_SOCKET_TYPE GetAsyncSocketType() const{return m_socktype;}

			/*!
				@brief Create async socket.

				@exception
					GAIA::ECT::EctInvalidParam If socktype is not a valid type.

				@exception
					GAIA::ECT::EctIllegal If socket is created.

				@exception
					GAIA::ECT::EctNetwork If there is not enough resource to create socket, throw it.

				@remarks This function is sync call.
			*/
			virtual GAIA::GVOID Create();

			/*!
				@brief Close async socket.

				@exception
					GAIA::ECT::EctIllegal If socket is not created.

				@exception
					GAIA::ECT::EctNetwork If close socket failed.
			 
				@remarks This function is sync call.
			*/
			virtual GAIA::GVOID Close();

			/*!
				@brief Shutdown current async socket.

				@param nShutdownFlag [in] Specify shutdown flag. @see GAIA::NETWORK::Socket::SOCKET_SHUTDOWN_FLAG.

				@exception
					GAIA::ECT::EctIllegal If socket is not created.

				@exception
					GAIA::ECT::EctNetwork If shutdown socket failed.
			 
				@remarks This function is sync call.

				@see GAIA::NETWORK::Socket::SOCKET_SHUTDOWN_FLAG.
			*/
			virtual GAIA::GVOID Shutdown(GAIA::N32 nShutdownFlag = GAIA::NETWORK::Socket::SSDF_RECV | GAIA::NETWORK::Socket::SSDF_SEND);

			/*!
				@brief Check current socket is create or not.

				@return If the socket is created, return GAIA::True, or will return GAIA::False.
			*/
			GAIA::BL IsCreated() const{return m_sock.IsCreated();}

			/*!
				@brief Set socket option.

				@param op [in] Specify the socket option name. @see GAIA::NETWORK::Socket::SOCKET_OPTION.

				@param v [in] Specify the socket option value.

				@exception
					GAIA::ECT::EctInvalidParam If parameter op is a invalid enum.

				@exception
					GAIA::ECT::EctIllegal If socket is not created.

				@exception
					GAIA::ECT::EctNetwork If set socket option failed.
			 
				@remarks This function is sync call.

				@see GAIA::NETWORK::Socket::SOCKET_OPTION.
			*/
			virtual GAIA::GVOID SetOption(GAIA::NETWORK::Socket::SOCKET_OPTION op, const GAIA::CTN::Vari& v){return m_sock.SetOption(op, v);}

			/*!
				@brief Get socket option.

				@param op [in] Specify the socket option name. @see GAIA::NETWORK::Socket::SOCKET_OPTION.

				@param v [out] Used for saving the socket option value.

				@exception
					GAIA::ECT::EctInvalidParam If parameter op is a invalid enum.

				@exception
					GAIA::ECT::EctIllegal If socket is not created.

				@see GAIA::NETWORK::Socket::SOCKET_OPTION.
			*/
			virtual GAIA::GVOID GetOption(GAIA::NETWORK::Socket::SOCKET_OPTION op, GAIA::CTN::Vari& v){return m_sock.GetOption(op, v);}

			/*!
				@brief Bind async socket to a network address, include IP and port.

				@param addr [in] Specify the address where will be bound.

				@exception
					GAIA::ECT::EctIllegal If socket is not created.

				@exception
					GAIA::ECT::EctNetwork If bind socket failed.
			 
				@remarks This function is sync call.
			*/
			virtual GAIA::GVOID Bind(const GAIA::NETWORK::Addr& addr);

			/*!
				@brief Check the socket is bound or not.

				@return If the socket is bound, return GAIA::True, or return GAIA::False.
			*/
			GAIA::BL IsBinded() const{return m_sock.IsBinded();}

			/*!
				@brief Connect async socket to a network address, include IP and port.

				@param addr [in] Specify the address where will connect.
			 
				@exception
					GAIA::ECT::EctIllegal If socket is not created.

				@remarks This function is async call.
			*/
			virtual GAIA::GVOID Connect(const GAIA::NETWORK::Addr& addr);

			/*!
				@brief Disconnect from a network address.

				@remarks This function is async call.
			*/
			virtual GAIA::GVOID Disconnect();

			/*!
				@brief Check current async socket is connected or not.
			*/
			GAIA::BL IsConnected() const{return m_sock.IsConnected();}

			/*!
				@brief Send data to peer.

				@param p [in] Specify the buffer which will be sent.

				@param nSize [in] Specify the buffer's size which will be sent.

				@return Return the practice size which will be sent.
			 
				@exception
					GAIA::ECT::EctIllegal If socket is not created.

				@remarks This function is async call.
			*/
			virtual GAIA::N32 Send(const GAIA::GVOID* p, GAIA::N32 nSize);

			/*!
				@brief Get socket file descriptor.

				@return Return the socket's file descriptor.
			*/
			GAIA::N32 GetFD() const{return m_sock.GetFD();}

			/*!
				@brief Get socket's bind address.

				@param addr [out] Used for saving the bound address.

				@return If success return GAIA::True, or return GAIA::False;

				@remarks If the socket is not bound, parameter addr will filled by "0.0.0.0:0".
			*/
			GAIA::BL GetBindedAddress(GAIA::NETWORK::Addr& addr){return m_sock.GetBindedAddress(addr);}

			/*!
				@brief Get socket's global address.

				@param addr [out] Used for saving the global address.

				@return If success return GAIA::True, or return GAIA::False.

				@remarks If there is not connection generated in global network, parameter addr will filled by "0.0.0.0:0".
			*/
			GAIA::BL GetGlobalAddress(GAIA::NETWORK::Addr& addr){return m_sock.GetGlobalAddress(addr);}

			/*!
				@brief Get socket's local address.

				@param addr [out] Used for saving the local address.

				@return If success return GAIA::True, or return GAIA::False.

				@remarks If the socket is not bound, parameter addr will filled by "0.0.0.0:0".
			*/
			GAIA::BL GetLocalAddress(GAIA::NETWORK::Addr& addr){return m_sock.GetLocalAddress(addr);}

			/*!
				@brief Get socket's peer address.

				@param addr [out] Used for saving the local address.

				@return If success return GAIA::True, or return GAIA::False.

				@remarks If the connection is not generated, parameter addr will filled by "0.0.0.0:0".
			*/
			GAIA::BL GetPeerAddress(GAIA::NETWORK::Addr& addr){return m_sock.GetPeerAddress(addr);}

		protected:
			
			/*!
				@brief On async socket created callback.
			 
				@param bResult [in] If create socket successfully, this parameter will be GAIA::True, or will be GAIA::False.
			 
				@remarks This function will be callbacked in multi-thread(any AsyncDispatcherThread) in designement.
			*/
			virtual GAIA::GVOID OnCreated(GAIA::BL bResult){}
			
			/*!
				@brief On async socket closed callback.
			 
				@param bResult [in] If close socket successfully, this parameter will be GAIA::True, or will be GAIA::False.
			 
				@remarks This function will be callbacked in multi-thread(any AsyncDispatcherThread) in designement.
			*/
			virtual GAIA::GVOID OnClosed(GAIA::BL bResult){}

			/*!
				@brief On async socket binded callback.
			 
				@param bResult [in] If bind socket to address successfully, this parameter will be GAIA::True, or will be GAIA::False.
			 
				@param addr [in] Specify the bound address.
			 
				@remarks This function will be callbacked in multi-thread(any AsyncDispatcherThread) in designement.
			*/
			virtual GAIA::GVOID OnBound(GAIA::BL bResult, const GAIA::NETWORK::Addr& addr){}

			/*!
				@brief On async socket connected callback.
			 
				@param bResult [in] If socket connect to peer successfully, this parameter will be GAIA::True, or will be GAIA::False.
			 
				@param addr [in] Specify the address where had connected to.
			 
				@remarks This function will be callbacked in multi-thread(any AsyncDispatcherThread) in designement.
			*/
			virtual GAIA::GVOID OnConnected(GAIA::BL bResult, const GAIA::NETWORK::Addr& addr){}

			/*!
				@brief On async socket disconnected callback.
			 
				@param bResult [in] If socket disconnect successfully, this parameter will be GAIA::True, or will be GAIA::False.
			 
				@param bByRemote [in] Specify the disconnect reason, if disconnect by remote side(peer), this parameter will be GAIA::True, or will be GAIA::False.
			 
				@remarks This function will be callbacked in multi-thread(any AsyncDispatcherThread) in designement.
			*/
			virtual GAIA::GVOID OnDisconnected(GAIA::BL bResult, GAIA::BL bByRemote){}

			/*!
				@brief On async socket started listen.
			 
				@param bResult [in] If socket listen successfully, this parameter will be GAIA::True, or will be GAIA::False.
			 
				@remarks This function will be callbacked in multi-thread(any AsyncDispatcherThread) in designement.
			*/
			virtual GAIA::GVOID OnListened(GAIA::BL bResult){}

			/*!
				@brief On async socket be accepted by a listen socket.
					Current object(this) will be the listen socket.
			 
				@param bResult [in] If accepted a new socket by a listen socket, this parameter will be GAIA::True, or will be GAIA::False.

				@param addrListen [in] Specify the address where had listen to.
			 
				@remarks This function will be callbacked in multi-thread(any AsyncDispatcherThread) in designement.
			*/
			virtual GAIA::GVOID OnAccepted(GAIA::BL bResult, const GAIA::NETWORK::Addr& addrListen){}

			/*!
				@brief On async socket sent callback.
			 
				@param bResult [in] If socket send data successfully, this parameter will be GAIA::True, or will be GAIA::False.
			 
				@param pData [in] Specify the buffer which had been sent.
			 
				@param nPracticeSize [in] Specify the practice size about the sent data in bytes.
			 
				@param nSize [in] Specify the wanted send size about the sent data in bytes.
			 
				@remarks This function will be callbacked in multi-thread(any AsyncDispatcherThread) in designement.
			*/
			virtual GAIA::GVOID OnSent(GAIA::BL bResult, const GAIA::GVOID* pData, GAIA::N32 nPracticeSize, GAIA::N32 nSize){}

			/*!
				@brief On async socket recv callback.
			 
				@param bResult [in] If socket receive data successfully, this parameter will be GAIA::True, or will be GAIA::False.
			 
				@param pData [in] Specify the received data buffer.
			 
				@param nSize [in] Specify the received data size in bytes.
			 
				@remarks This function will be callbacked in multi-thread(any AsyncDispatcherThread) in designement.
			*/
			virtual GAIA::GVOID OnRecved(GAIA::BL bResult, const GAIA::GVOID* pData, GAIA::N32 nSize){}

			/*!
				@brief On async socket shutdown callback.
			 
				@param bResult [in] If socket shutdowned successfully, this parameter will be GAIA::True, or will be GAIA::False.
			 
				@param nShutdownFlag [in] Specify the shutdown flag. @see GAIA::NETWORK::Socket::SOCKET_SHUTDOWN_FLAG.
			 
				@remarks This function will be callbacked in multi-thread(any AsyncDispatcherThread) in designement.
			 
				@see GAIA::NETWORK::Socket::SOCKET_SHUTDOWN_FLAG.
			*/
			virtual GAIA::GVOID OnShutdowned(GAIA::BL bResult, GAIA::N32 nShutdownFlag){}

		private:
			GAIA::GVOID init();
			GAIA::BL SetFD(GAIA::N32 nFD){return m_sock.SetFD(nFD);}
			GAIA::BL SetType(GAIA::NETWORK::Socket::SOCKET_TYPE type){return m_sock.SetType(type);}
			GAIA::BL SetBinded(GAIA::BL bBinded){return m_sock.SetBinded(bBinded);}
			GAIA::BL SetConnected(GAIA::BL bConnected){return m_sock.SetConnected(bConnected);}
			GAIA::GVOID SetAsyncSocketType(GAIA::NETWORK::ASYNC_SOCKET_TYPE socktype){m_socktype = socktype;}
			GAIA::GVOID SetPeerAddress(const GAIA::NETWORK::Addr& addr){m_sock.SetPeerAddress(addr);}

		#if GAIA_OS == GAIA_OS_WINDOWS
			GAIA::BL SwapBrokenState()
			{
				GAIA::N64 lNewValue = m_atomBrokenTimes.Increase();
				GAST(lNewValue > 0);
				return lNewValue == 1;
			}
		#endif

		private:
			GAIA::NETWORK::AsyncDispatcher* m_pDispatcher;
			GAIA::NETWORK::ASYNC_SOCKET_TYPE m_socktype;
			GAIA::NETWORK::Socket m_sock;
			GAIA::SYNC::Lock m_lrSend;
			GAIA::SYNC::LockPure m_lrCB;

		#if GAIA_OS == GAIA_OS_WINDOWS
			GAIA::SYNC::Atomic m_atomBrokenTimes;
			GAIA::GVOID* m_pfnAcceptEx;
			GAIA::GVOID* m_pfnConnectEx;
			GAIA::GVOID* m_pfnDisconnectEx;
		#else
			GAIA::CTN::BufferRW m_sendbuf;
			AsyncContext* m_pReadAsyncCtx;
			AsyncContext* m_pWriteAsyncCtx;
			GAIA::U64 m_uRecycleTime;
			GAIA::N32 m_nBackupSocket;
			GAIA::BL m_bPushForRecycleAble;
		#endif
		};
	}
}

#endif
